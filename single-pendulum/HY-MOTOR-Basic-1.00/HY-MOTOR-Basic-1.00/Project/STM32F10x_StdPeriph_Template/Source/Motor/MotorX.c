/**
  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ******************************************************************************
  * @file    Project\STM32F10x_StdPeriph_Template\Source\Motor\motor.c 
  * @author  CCW Application Team
  * @version V3.5.0
  * @date    2013-10-26
  * @brief   Main program body
  ******************************************************************************
  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
**/

#include "main.h"


u32 LEDErrorStatus     = 0;

s16 CounterPanEncoder  = 0;
s16 CounterTiltEncoder = 0;

//-----------main and motor------------------------------------------------------------------
u16 MotorXSpeedPos 						   	          = 0;
s32 CounterMotorXStepPostionCurrent         = StartPostion; //步进电机1当前位置计数器
u16 MotorXStep_StartStop                    = 380;	//最高速度 MotorSpeed

//-----------------------------------------------------------------------------------
/*****************************************************************************************/
static u16 step_startstop 				   	      = 0;	//起停距离1 256微步 起停距离2 512微步
//static u16 SmallStepCurrent 				 	          = SMALL_STEP;       //当前步进电机细分步数寄存器 127  64  32  16  8  4  2  1步 //步进电机细分步数 初始设置
static u8  LineFlag						              = YES;
//----------------------------Motor-1---------------------------------------------------------------
static s16 MotorPositionPointer             = 0;  
static u8  Motor1_Stop_Flag                 = 0;
static u8  Motor1_dir                       = 1;  
static u8  Motor1WillBackFlag               = 0;
static u8  Motor1_dir_Current               = 1;
static u8  Motor1_speed_postion_dir         = 1;
static s32 Motor1_postion_Current           = StartPostion;
static s32 Motor1_postion_user              = StartPostion;
static s32 Motor1_dynamic_postion_gap       = 0;           
static s32 Motor1_user_postion_gap          = 0;           
//-----------------------------------------------------------------------------------------------


//步进电机(128-8)微步细分速度数据表：
//-------------------------------------------
// double C0 = 69------- 
// double C0UP = 9.98------- 
// StepMAX = 514------- 
// K0 = 1------- 
// B0 = 3------- 
// K1 = 1------- 
// B1 = 0------- 
// K2 = 3------- 
// double τ = 41.08------- 
// 时钟频率 = 16------- 
// 分频值 = 8------- 
// 细分数 = 65------- 
//-------------------------------------------
// 步进电机速度 =  7.50--194.24 r/min-------------------------------------------
//-------------------------------------------

const u16 SpeedCurveTimerVal[514]={
37712,60533,62024,62700,63103,63376,63577,63732,63856,63959,64045,64119,64183,64239,64289,64334,64375,64411,64445,64476,
64504,64530,64554,64577,64598,64618,64637,64655,64671,64687,64702,64716,64730,64743,64755,64767,64778,64789,64799,64809,
64818,64828,64837,64845,64853,64861,64869,64876,64883,64890,64897,64904,64910,64916,64922,64928,64934,64939,64945,64950,
64955,64960,64965,64969,64974,64978,64983,64987,64991,64995,64999,65003,65007,65011,65015,65018,65022,65025,65029,65032,
65035,65038,65041,65045,65048,65051,65053,65056,65059,65062,65065,65067,65070,65073,65075,65078,65080,65082,65085,65087,
65089,65092,65094,65096,65098,65101,65103,65105,65107,65109,65111,65113,65115,65117,65119,65120,65122,65124,65126,65128,
65129,65131,65133,65135,65136,65138,65139,65141,65143,65144,65146,65147,65149,65150,65152,65153,65155,65156,65157,65159,
65160,65162,65163,65164,65166,65167,65168,65170,65171,65172,65173,65175,65176,65177,65178,65179,65180,65182,65183,65184,
65185,65186,65187,65188,65189,65191,65192,65193,65194,65195,65196,65197,65198,65199,65200,65201,65202,65203,65204,65205,
65206,65206,65207,65208,65209,65210,65211,65212,65213,65214,65215,65215,65216,65217,65218,65219,65220,65220,65221,65222,
65223,65224,65224,65225,65226,65227,65228,65228,65229,65230,65231,65231,65232,65233,65233,65234,65235,65236,65236,65237,
65238,65238,65239,65240,65240,65241,65242,65242,65243,65244,65244,65245,65246,65246,65247,65248,65248,65249,65249,65250,
65251,65251,65252,65252,65253,65254,65254,65255,65255,65256,65256,65257,65258,65258,65259,65259,65260,65260,65261,65261,
65262,65263,65263,65264,65264,65265,65265,65266,65266,65267,65267,65268,65268,65269,65269,65270,65270,65271,65271,65272,
65272,65273,65273,65274,65274,65274,65275,65275,65276,65276,65277,65277,65278,65278,65279,65279,65279,65280,65280,65281,
65281,65282,65282,65282,65283,65283,65284,65284,65285,65285,65285,65286,65286,65287,65287,65287,65288,65288,65289,65289,
65289,65290,65290,65291,65291,65291,65292,65292,65292,65293,65293,65294,65294,65294,65295,65295,65295,65296,65296,65296,
65297,65297,65298,65298,65298,65299,65299,65299,65300,65300,65300,65301,65301,65301,65302,65302,65302,65303,65303,65303,
65304,65304,65304,65305,65305,65305,65306,65306,65306,65307,65307,65307,65307,65308,65308,65308,65309,65309,65309,65310,
65310,65310,65311,65311,65311,65311,65312,65312,65312,65313,65313,65313,65313,65314,65314,65314,65315,65315,65315,65315,
65316,65316,65316,65317,65317,65317,65317,65318,65318,65318,65318,65319,65319,65319,65320,65320,65320,65320,65321,65321,
65321,65321,65322,65322,65322,65322,65323,65323,65323,65323,65324,65324,65324,65324,65325,65325,65325,65325,65326,65326,
65326,65326,65327,65327,65327,65327,65328,65328,65328,65328,65328,65329,65329,65329,65329,65330,65330,65330,65330,65331,
65331,65331,65331,65331,65332,65332,65332,65332,65333,65333,65333,65333,65333,65334,65334,65334,65334,65334,65335,65335,
65335,65335,65336,65336,65336,65336,65336,65337,65337,65337,65337,65337,65338,65338,65338,65338,65338,65339,65339,65339,
65339,65339,65340,65340,65340,65340,65340,65341,65341,65341,65341,65341,65342,65342,
};



/*
//-------------------------------------------
// double C0 = 33------- 
// double C0UP = 4------- 
// StepMAX = 256------- 
// K0 = 1------- 
// B0 = 3------- 
// K1 = 1------- 
// B1 = 0------- 
// K2 = 2------- 
// double τ = 30.7------- 
// 时钟频率 = 16------- 
// 分频值 = 8------- 
// 细分数 = 64------- 
//-------------------------------------------
// 步进电机速度 = 18.95--288.19 r/min-------------------------------------------
//-------------------------------------------
const u16 SpeedCurveTimerVal[257]={
59378,
59378,63556,64070,64322,64479,64588,64669,64733,64785,64828,64864,64896,64923,64947,64969,64988,65006,65022,65036,65050,
65062,65074,65084,65095,65104,65113,65121,65129,65136,65143,65150,65156,65162,65168,65174,65179,65184,65189,65194,65198,
65202,65206,65210,65214,65218,65222,65225,65228,65232,65235,65238,65241,65244,65247,65249,65252,65254,65257,65259,65262,
65264,65266,65269,65271,65273,65275,65277,65279,65281,65283,65284,65286,65288,65290,65291,65293,65295,65296,65298,65299,
65301,65302,65304,65305,65307,65308,65309,65311,65312,65313,65314,65316,65317,65318,65319,65320,65321,65323,65324,65325,
65326,65327,65328,65329,65330,65331,65332,65333,65334,65335,65336,65337,65337,65338,65339,65340,65341,65342,65343,65343,
65344,65345,65346,65347,65347,65348,65349,65350,65350,65351,65352,65353,65353,65354,65355,65355,65356,65357,65357,65358,
65359,65359,65360,65360,65361,65362,65362,65363,65363,65364,65365,65365,65366,65366,65367,65367,65368,65368,65369,65370,
65370,65371,65371,65372,65372,65373,65373,65374,65374,65375,65375,65375,65376,65376,65377,65377,65378,65378,65379,65379,
65380,65380,65380,65381,65381,65382,65382,65383,65383,65383,65384,65384,65385,65385,65385,65386,65386,65386,65387,65387,
65388,65388,65388,65389,65389,65389,65390,65390,65391,65391,65391,65392,65392,65392,65393,65393,65393,65394,65394,65394,
65395,65395,65395,65395,65396,65396,65396,65397,65397,65397,65398,65398,65398,65399,65399,65399,65399,65400,65400,65400,
65401,65401,65401,65401,65402,65402,65402,65403,65403,65403,65403,65404,65404,65404,65404,65405,
};
*/

const u16 SinData[513] =   //128*4
{
750, 759, 768, 777, 786, 795, 805, 814, 823, 832, 841, 850, 860, \
869, 878, 887, 896, 905, 914, 923, 932, 941, 950, 958, 967, 976, 985, \
993, 1002, 1011, 1019, 1028, 1037, 1045, 1053, 1062, 1070, 1078, \
1087, 1095, 1103, 1111, 1119, 1127, 1135, 1143, 1151, 1158, 1166, \
1174, 1181, 1189, 1196, 1204, 1211, 1218, 1225, 1232, 1239, 1246, \
1253, 1260, 1267, 1273, 1280, 1286, 1293, 1299, 1305, 1311, 1317, \
1323, 1329, 1335, 1341, 1346, 1352, 1357, 1363, 1368, 1373, 1378, \
1383, 1388, 1393, 1397, 1402, 1407, 1411, 1415, 1419, 1424, 1427, \
1431, 1435, 1439, 1442, 1446, 1449, 1453, 1456, 1459, 1462, 1464, \
1467, 1470, 1472, 1475, 1477, 1479, 1481, 1483, 1485, 1487, 1488, \
1490, 1491, 1493, 1494, 1495, 1496, 1497, 1497, 1498, 1499, 1499, \
1499, 1499, 1500, 1499, 1499, 1499, 1499, 1498, 1497, 1497, 1496, \
1495, 1494, 1493, 1491, 1490, 1488, 1487, 1485, 1483, 1481, 1479, \
1477, 1475, 1472, 1470, 1467, 1464, 1462, 1459, 1456, 1453, 1449, \
1446, 1442, 1439, 1435, 1431, 1427, 1424, 1419, 1415, 1411, 1407, \
1402, 1397, 1393, 1388, 1383, 1378, 1373, 1368, 1363, 1357, 1352, \
1346, 1341, 1335, 1329, 1323, 1317, 1311, 1305, 1299, 1293, 1286, \
1280, 1273, 1267, 1260, 1253, 1246, 1239, 1232, 1225, 1218, 1211, \
1204, 1196, 1189, 1181, 1174, 1166, 1158, 1151, 1143, 1135, 1127, \
1119, 1111, 1103, 1095, 1087, 1078, 1070, 1062, 1053, 1045, 1037, \
1028, 1019, 1011, 1002, 993, 985, 976, 967, 958, 950, 941, 932, 923, \
914, 905, 896, 887, 878, 869, 860, 850, 841, 832, 823, 814, 805, 795, \
786, 777, 768, 759, 750, 740, 731, 722, 713, 704, 694, 685, 676, 667, \
658, 649, 639, 630, 621, 612, 603, 594, 585, 576, 567, 558, 549, 541, \
532, 523, 514, 506, 497, 488, 480, 471, 462, 454, 446, 437, 429, 421, \
412, 404, 396, 388, 380, 372, 364, 356, 348, 341, 333, 325, 318, 310, \
303, 295, 288, 281, 274, 267, 260, 253, 246, 239, 232, 226, 219, 213, \
206, 200, 194, 188, 182, 176, 170, 164, 158, 153, 147, 142, 136, 131, \
126, 121, 116, 111, 106, 102, 97, 92, 88, 84, 80, 75, 72, 68, 64, 60, \
57, 53, 50, 46, 43, 40, 37, 35, 32, 29, 27, 24, 22, 20, 18, 16, 14, \
12, 11, 9, 8, 6, 5, 4, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, \
2, 3, 4, 5, 6, 8, 9, 11, 12, 14, 16, 18, 20, 22, 24, 27, 29, 32, 35, \
37, 40, 43, 46, 50, 53, 57, 60, 64, 68, 72, 75, 80, 84, 88, 92, 97, \
102, 106, 111, 116, 121, 126, 131, 136, 142, 147, 153, 158, 164, 170, \
176, 182, 188, 194, 200, 206, 213, 219, 226, 232, 239, 246, 253, 260, \
267, 274, 281, 288, 295, 303, 310, 318, 325, 333, 341, 348, 356, 364, \
372, 380, 388, 396, 404, 412, 421, 429, 437, 446, 454, 462, 471, 480, \
488, 497, 506, 514, 523, 532, 541, 549, 558, 567, 576, 585, 594, 603, \
612, 621, 630, 639, 649, 658, 667, 676, 685, 694, 704, 713, 722, 731, \
740, 750
};

const u16 CosData[513]=
{
1500, 1499, 1499, 1499, 1499, 1498, 1497, 1497, 1496, 1495, 1494, \
1493, 1491, 1490, 1488, 1487, 1485, 1483, 1481, 1479, 1477, 1475, \
1472, 1470, 1467, 1464, 1462, 1459, 1456, 1453, 1449, 1446, 1442, \
1439, 1435, 1431, 1427, 1424, 1419, 1415, 1411, 1407, 1402, 1397, \
1393, 1388, 1383, 1378, 1373, 1368, 1363, 1357, 1352, 1346, 1341, \
1335, 1329, 1323, 1317, 1311, 1305, 1299, 1293, 1286, 1280, 1273, \
1267, 1260, 1253, 1246, 1239, 1232, 1225, 1218, 1211, 1204, 1196, \
1189, 1181, 1174, 1166, 1158, 1151, 1143, 1135, 1127, 1119, 1111, \
1103, 1095, 1087, 1078, 1070, 1062, 1053, 1045, 1037, 1028, 1019, \
1011, 1002, 993, 985, 976, 967, 958, 950, 941, 932, 923, 914, 905, \
896, 887, 878, 869, 860, 850, 841, 832, 823, 814, 805, 795, 786, 777, \
768, 759, 750, 740, 731, 722, 713, 704, 694, 685, 676, 667, 658, 649, \
639, 630, 621, 612, 603, 594, 585, 576, 567, 558, 549, 541, 532, 523, \
514, 506, 497, 488, 480, 471, 462, 454, 446, 437, 429, 421, 412, 404, \
396, 388, 380, 372, 364, 356, 348, 341, 333, 325, 318, 310, 303, 295, \
288, 281, 274, 267, 260, 253, 246, 239, 232, 226, 219, 213, 206, 200, \
194, 188, 182, 176, 170, 164, 158, 153, 147, 142, 136, 131, 126, 121, \
116, 111, 106, 102, 97, 92, 88, 84, 80, 75, 72, 68, 64, 60, 57, 53, \
50, 46, 43, 40, 37, 35, 32, 29, 27, 24, 22, 20, 18, 16, 14, 12, 11, \
9, 8, 6, 5, 4, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 4, \
5, 6, 8, 9, 11, 12, 14, 16, 18, 20, 22, 24, 27, 29, 32, 35, 37, 40, \
43, 46, 50, 53, 57, 60, 64, 68, 72, 75, 80, 84, 88, 92, 97, 102, 106, \
111, 116, 121, 126, 131, 136, 142, 147, 153, 158, 164, 170, 176, 182, \
188, 194, 200, 206, 213, 219, 226, 232, 239, 246, 253, 260, 267, 274, \
281, 288, 295, 303, 310, 318, 325, 333, 341, 348, 356, 364, 372, 380, \
388, 396, 404, 412, 421, 429, 437, 446, 454, 462, 471, 480, 488, 497, \
506, 514, 523, 532, 541, 549, 558, 567, 576, 585, 594, 603, 612, 621, \
630, 639, 649, 658, 667, 676, 685, 694, 704, 713, 722, 731, 740, 750, \
759, 768, 777, 786, 795, 805, 814, 823, 832, 841, 850, 860, 869, 878, \
887, 896, 905, 914, 923, 932, 941, 950, 958, 967, 976, 985, 993, \
1002, 1011, 1019, 1028, 1037, 1045, 1053, 1062, 1070, 1078, 1087, \
1095, 1103, 1111, 1119, 1127, 1135, 1143, 1151, 1158, 1166, 1174, \
1181, 1189, 1196, 1204, 1211, 1218, 1225, 1232, 1239, 1246, 1253, \
1260, 1267, 1273, 1280, 1286, 1293, 1299, 1305, 1311, 1317, 1323, \
1329, 1335, 1341, 1346, 1352, 1357, 1363, 1368, 1373, 1378, 1383, \
1388, 1393, 1397, 1402, 1407, 1411, 1415, 1419, 1424, 1427, 1431, \
1435, 1439, 1442, 1446, 1449, 1453, 1456, 1459, 1462, 1464, 1467, \
1470, 1472, 1475, 1477, 1479, 1481, 1483, 1485, 1487, 1488, 1490, \
1491, 1493, 1494, 1495, 1496, 1497, 1497, 1498, 1499, 1499, 1499, \
1499, 1500
};
/*
//========================================================================================
void MotorXDriveInTimer(void)  //最简化版   
{
    static u16 MotorPositionPointer = 0;
    u8 MotorX_Dir = 0;
    
    TIM1CCR3_Val	= 65535 - SpeedCurveTimerVal[120];  //u16
  
    if (MotorX_Dir)
    {
        MotorPositionPointer += 16; //512/4/16=8细分 
        if (MotorPositionPointer >= 512)  MotorPositionPointer = 0;
    }
    else
    {
        MotorPositionPointer -= 16;
        if (MotorPositionPointer <= 0)  MotorPositionPointer = 512;
    }
    
    //MotorPositionPointer = 32;
    
      TIM2->CCR1 =          SinData[MotorPositionPointer];
      TIM2->CCR2 = CyclePWM-SinData[MotorPositionPointer];
      TIM2->CCR3 =          CosData[MotorPositionPointer];
      TIM2->CCR4 = CyclePWM-CosData[MotorPositionPointer];
}
*/

/*
//========================================================================================
void MotorYDriveInTimer(void)  //最简化版
{
    static u16 MotorPositionPointer = 0;
    
    if (MotorY_Dir)
    {
        MotorPositionPointer += 1;
        if (MotorPositionPointer >= 512)  MotorPositionPointer = 0;
    }
    else
    {
        MotorPositionPointer -= 1;
        if (MotorPositionPointer <= 0)  MotorPositionPointer = 512;
    }
    
      TIM4->CCR1 =          SinData[MotorPositionPointer];
      TIM4->CCR2 = CyclePWM-SinData[MotorPositionPointer];
      TIM4->CCR3 =          CosData[MotorPositionPointer];
      TIM4->CCR4 = CyclePWM-CosData[MotorPositionPointer];
}
*/

/*****************************************************************************
*		s32	CheckValChange 	   two times
*****************************************************************************/
static u8 CheckValChange1(s32 Val)
{
    static s32 tempa1    = 0;
    static s32 tempb1    = 0;
    static u8  i         = 0;
	static u8  m		 = 0;

//-------------------------------------------------------------------
    i++;
    switch (i)
    {
    case 1:
        tempa1 = Val;
        break;
    case 2:
        i = 0;      //CLR 0
        tempb1 = Val;
        break;
    }
   //-------------------------------
    if (tempa1 != tempb1)
		m = YES;
	else
		m = NO;

		return m;
//-------------------------------------------------------------------
}

/*******************************************************************/
static u8 CheckValChange2(s32 Val)
{
    static s32 tempa1    = 0;
    static s32 tempb1    = 0;
    static u8  i         = 0;
	static u8  m		 = 0;

//-------------------------------------------------------------------
    i++;
    switch (i)
    {
    case 1:
        tempa1 = Val;
        break;
    case 2:
        i = 0;      //CLR 0
        tempb1 = Val;
        break;
    }
   //-------------------------------
    if (tempa1 != tempb1)
		m = YES;
	else
		m = NO;

		return m;
//-------------------------------------------------------------------
}

/*******************************************************************/
static u8 CheckValChange3(s32 Val)
{
    static s32 tempa1    = 0;
    static s32 tempb1    = 0;
    static u8  i         = 0;
	static u8  m		 = 0;

//-------------------------------------------------------------------
    i++;
    switch (i)
    {
    case 1:
        tempa1 = Val;
        break;
    case 2:
        i = 0;      //CLR 0
        tempb1 = Val;
        break;
    }
   //-------------------------------
    if (tempa1 != tempb1)
		m = YES;
	else
		m = NO;

		return m;
//-------------------------------------------------------------------
}

//----------------------------Motor1WaitProgram--------------------------------------------------------------
static void Motor1WaitProgram(void)
{
    if (Motor1_postion_user  > Motor1_postion_Current)  
    {
        Motor1_user_postion_gap   = Motor1_postion_user - Motor1_postion_Current;  
        if (Motor1_dir_Current == 1)  //MotorXSpeedPos
        {
            Motor1WillBackFlag = 0;
        }
        else
        {
            Motor1WillBackFlag = 1;
        }
        if (Motor1_Stop_Flag) Motor1_speed_postion_dir = YES;
    }
    //--------------------------------------------------------------------------------------------------------------------------
    if (Motor1_postion_user  < Motor1_postion_Current)  
    {
        Motor1_user_postion_gap   = Motor1_postion_Current  - Motor1_postion_user;  
        if (Motor1_dir_Current == 0)
        {
            Motor1WillBackFlag = 0;
        }
        else
        {
            Motor1WillBackFlag = 1;
        }
        if (Motor1_Stop_Flag) Motor1_speed_postion_dir = NO;
    }
//-----------------------------------------------------------------------------------
    if (Motor1_user_postion_gap <= 8*MaxStep)
    {
        step_startstop = Motor1_user_postion_gap/MaxStep / 4;
    }
    else if ((8*MaxStep < Motor1_user_postion_gap) && (Motor1_user_postion_gap < MotorXStep_StartStop*2*MaxStep)) //<=512*2
    {   // only two state
        step_startstop = Motor1_user_postion_gap/MaxStep / 2;
    }
    else
    {
        step_startstop = MotorXStep_StartStop;
    }
}


//==============================================================================================================

//-------------------------------------------------------------------------------------------------------------------------
/*****************************************************************************************
*
*				 步进电机驱动根据位置，控制速度函数 
*       
*****************************************************************************************/
static void Motor1DynamicPostionGap(void)             // LOOP IN TIME0 48us
{
   
//------------------------------------------------------------------------
    if (!MotorXSpeedPos)
    {
        Motor1_Stop_Flag = 1;
    }
    else
    {
        Motor1_Stop_Flag = 0;
    }
    //-------------------------------------------------------------------
    if (Motor1_Stop_Flag)  //如果当前电机已经停止  再检查
    {
        Motor1WaitProgram();
    }
//---------------------------------------------------------------------------------------------------------------
    
	if (Motor1_postion_user == Motor1_postion_Current)
    {
	    Motor1_dynamic_postion_gap = 0;

	} 
	//---------------------------------------------------------------------------------
    else if (Motor1_postion_user  > Motor1_postion_Current)   
    {  // 同向
        Motor1_dynamic_postion_gap  = Motor1_postion_user - Motor1_postion_Current;   //位置差 Postion_gap   一个位置差为10步 一圈200步
		if (Motor1_Stop_Flag) Motor1_speed_postion_dir = YES;
    }
	//-----------------------------------------------------------------------------------
    else if (Motor1_postion_user < Motor1_postion_Current)       
    {
        Motor1_dynamic_postion_gap  = Motor1_postion_Current - Motor1_postion_user;    //反向位置差值
		if (Motor1_Stop_Flag)  Motor1_speed_postion_dir = NO;
    }
//-----------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------


/*****************************************************************************************
*
*				 步进电机驱动函数 
*       
*      Motor1_drive(Motor1_speed_postion_dir,20,Motor1_dynamic_postion_gap/100);
*****************************************************************************************/
static void Motor1_drive(u8 dir,u16 SpeedPostion)    //STEP  步进电机步数  200步 为一圈
{
    static u16 SpeedVal =0;

	  SpeedVal = SpeedCurveTimerVal[SpeedPostion];
  
    //----------------------------------------------------------------------
    Motor1_dir    = dir;
    TIM1CCR3_Val	= 65535 - SpeedVal;  //u16

}

/*****************************************************************************************
*
*				 步进电机根据当前位置 控制 速度 达到指定位置 驱动函数 
*                                
*****************************************************************************************/
static void Motor1PostionControlSpeed(void)          // LOOP IN T0
{

//---------------------------------------------------------------------------------------
	if (CheckValChange3(Motor1_dynamic_postion_gap))
	{
	  	if (((Motor1_user_postion_gap-step_startstop*MaxStep) < Motor1_dynamic_postion_gap) && (Motor1_dynamic_postion_gap <= Motor1_user_postion_gap))
            LineFlag = 1;  //1 加速  0 减速  2 匀速 (停止)  
	}

    Motor1_drive(Motor1_speed_postion_dir,MotorXSpeedPos);

	//MicroStep and MaxStep  Motor1_postion_Current	  Motor1_dynamic_postion_gap
	//-------- CheckValChange --------
    if (CheckValChange2(Motor1_dynamic_postion_gap/MaxStep))
    {
        if (Motor1WillBackFlag==0)
        {   //-----------------------------------------------------------------
            if ((0 < Motor1_dynamic_postion_gap) && (Motor1_dynamic_postion_gap <= MotorXSpeedPos*MaxStep))  //loop 20*256/x (256-32) 20为20步
            {
                if (MotorXSpeedPos)
                {
                    MotorXSpeedPos--;  //减速制动
                    LineFlag = 0;
                }
            }//-----------------------------------------------------------------
            else if ((step_startstop*MaxStep < Motor1_dynamic_postion_gap) && (Motor1_dynamic_postion_gap <= (Motor1_user_postion_gap-step_startstop*MaxStep)))
            {
                LineFlag = 2;
            }//-----------------------------------------------------------------
            else if (((Motor1_user_postion_gap-step_startstop*MaxStep) < Motor1_dynamic_postion_gap) && (Motor1_dynamic_postion_gap <= Motor1_user_postion_gap))
            {
                if (MotorXSpeedPos<step_startstop)
                {
                    MotorXSpeedPos++;  //加速启动
                    LineFlag = 1;
                }
            }//-----------------------------------------------------------------
            else if (Motor1_dynamic_postion_gap > Motor1_user_postion_gap)
            {
                Motor1WillBackFlag = 1;  //减速制动
            }
        }
        //----------------------------------------------------------------------------------------
        else if ((Motor1WillBackFlag==1))
        {   
            if (MotorXSpeedPos)
            {
                MotorXSpeedPos--;
                LineFlag = 0;
            }
            else
            {
                Motor1WillBackFlag = 0;
            }
        }
    }

//----------------------------------------------------------------------------------------------------------------------------------------------
}


/*****************************************************************************************
*      当前步进电机状态寄存器   方向  速度  角度 等信息记录
*****************************************************************************************/
static void Motor1PointerControl(void)        //100us*32 == 3.2ms     LOOP in Time0
{
	static u16 iStop = 0;

	//----------------------------------------------------------------------DmxFinedataUser
    if ((Motor1_postion_Current == Motor1_postion_user)&&(!MotorXSpeedPos))//&&(DmxFinedataUser==CounterFinedataCurrent))
    { 
        Motor1_user_postion_gap    = 0;
        Motor1_dynamic_postion_gap = 0;

        LineFlag = 2;//YES;	

        //StopFlag = 1;        
        
        //------------------------------------------------------------       
        if (iStop > 100) //655us/2*500
        {
            TIM2->CCR1 =          (SinData[MotorPositionPointer])>>2;
            TIM2->CCR2 = (CyclePWM-SinData[MotorPositionPointer])>>2;
            TIM2->CCR3 =          (CosData[MotorPositionPointer])>>2;
            TIM2->CCR4 = (CyclePWM-CosData[MotorPositionPointer])>>2;
            //LED_FLASH(1);
        }
        else
        {
            iStop++;
        }
        //----------------STOP AND AUTO TURN BACK---------------------
		        //Motor1_StopAutoBACK();
        //------------------------------------------------------------
    }
    else   //---(Motor1_postion_Current != Motor1_postion_user)---
    {
        //Motor1_Arrive_Flag = 0;   //电机停止 用户设定位置未到达 标记
		//------------------------------------------------------------
      iStop = 0;  
      //StopFlag = 0;  
        
	    TIM2->CCR1 =          SinData[MotorPositionPointer];
      TIM2->CCR2 = CyclePWM-SinData[MotorPositionPointer];
      TIM2->CCR3 =          CosData[MotorPositionPointer];
      TIM2->CCR4 = CyclePWM-CosData[MotorPositionPointer];


		//---------正反转控制-----------------------------------------
        if (Motor1_dir == 1)            //用户欲控制方向 为正向时  
            Motor1_dir_Current     = 1;
        else                           //用户欲控制方向 为反向时
            Motor1_dir_Current     = 0;
		//------------------------------------------------------------
        
      if (Motor1_dir_Current == YES)   //控制步进电机 正向旋转
      {
          //不加则停止转动 锁定状态
           
            MotorPositionPointer += 8;
            CounterMotorXStepPostionCurrent += 1;

          //--------------------------------------------------
          
		  if (MotorPositionPointer >= 512)  MotorPositionPointer = 0; 
     }
     else                //控制步进电机 反向旋转
     {                          
	
            MotorPositionPointer -= 8;
            CounterMotorXStepPostionCurrent -= 1;
          //--------------------------------------------------
          if (MotorPositionPointer <= 0)  MotorPositionPointer = 512; 
     }
  } 

//---------------------------------------------------------------------------------------------------------------
	Motor1_postion_Current = CounterMotorXStepPostionCurrent;
    //当前状态侦测  并存入状态寄存器 存入当前状态	    
//---------------------------------------------------------------------------------------------------------------
}

/*****************************************************************************************
*
*				 步进电机  位置  控制函数 
*                         void Motor1_postion_control(u16 Motor1_postion)   0-255
*****************************************************************************************/
static void Motor1_postion_control(s32 postion)   // 一个位置 ==  ？
{

    if (CheckValChange1(postion))
    {
        //-------------------------------------------------------------------------------------------------
        Motor1_postion_user      = postion;     //用户设定位置  全局变量
        Motor1WaitProgram();
    }//-----------------------------------------------------------------------------------------------------
}

/********************************************************************
*
*          Motor1DmxDataControl
*
*********************************************************************/
void MotorXDmxDataControl(u8 Dmxdata,u8 Finedata)
{    //0-255 ==== 0-9R*200 =1800  1800/255 = 7.05     540/360=1.5 *变比==> 1.5*6=9
    static s32 i=0;
	static u8 RatioA  = 8;//50;   //8  9
	static u8 RatioB  = 1;//255;   //1

	//i = (s32)((Dmxdata*MaxStep*RatioA/RatioB)+Finedata+StartPostion);
    i = (s32)((Dmxdata*MaxStep*RatioA/RatioB)+Finedata);

        //---------每步大于一步1.8--------------------------------------------------	
	//i = (Dmxdata*RatioA/RatioB)+(Finedata)/MaxStep+StartPostion;  //+100 6	 Step
	//DmxFinedataUser = (Finedata)%MaxStep;	
						  //Micro-Step
	//---------每步小于一步1.8--------------------------------------------------
	//i = Dmxdata*RatioA/RatioB + StartPostion;
    //DmxFinedataUser = (u8)(Dmxdata*RatioA*MaxStep/RatioB) % MaxStep;

    //i = 20*Dmxdata;
    Motor1_postion_control(i);
}

/*****************************************************************************************
*
*				 步进电机 动态位置  速度控制位置  驱动函数 
*                                     
*****************************************************************************************/

void MotorXDriveInTimer(void)
{
    Motor1PointerControl();
    Motor1DynamicPostionGap();
    Motor1PostionControlSpeed(); 
}


/*****************************************************************************
*		s32	CheckValChange 	   two times
*****************************************************************************/
static u8 CheckValChangeX(s16 Val)
{
    static s16 tempa1    = 0;
	static u8  m		 = 0;

//-------------------------------------------------------------------

    if (tempa1 < Val)
    {
        m = YES;
    } 
    else
    {
        m = NO;
    }        
    
    tempa1 = Val;
    
    return m;
    
//-------------------------------------------------------------------
}

/*******************************************************************/
static u8 CheckValChangeY(s16 Val)
{
    static s16 tempa1    = 0;
	static u8  m		 = 0;

//-------------------------------------------------------------------

    if (tempa1 < Val)
    {
        m = YES;
    } 
    else
    {
        m = NO;
    }        
    
    tempa1 = Val;
    
    return m;
//-------------------------------------------------------------------
}

//===============================================================================
void ResetMotorFunction(void)
{
    static u8  Index        = 0;
    static u8  SuccessFlag  = 0;
    static u32 HallOutTime  = 128*200*11;
    //static u8  MotorX_Dir   = 1;
    
    //u16 iStart = 0;
    
  while((Index < 8) && HallOutTime)	//hall检测到信号或时间到 则退出
	{
	  
		HallOutTime--;
        
    MotorXStep_StartStop = 5;
    Motor1_postion_Current   = 0;
    Motor1_postion_user  = MotorXResetBackPostion; 
    
    delayms(1);

     if ((HallOutTime%100) == 0) //512
     {         
        //-HALL-Pan PIN12 13==0 ----
        if(!CheckValChangeX(CounterPanEncoder))
        {
            
            SuccessFlag |= PanHall;
            CounterMotorXStepPostionCurrent 	= MotorXResetBackPostion-StartPostion-MaxStep*200;//StartPostion+MaxStep*200;
            //DMXData[pDMX->Pan] 		= 0;
        }
        printf("CounterPanEncoder-->%d\r\n",CounterPanEncoder);
     }   
        
        //-HALL-Tilt PIN11==0
	  if(!CheckValChangeY(CounterTiltEncoder))		
	 	{

            SuccessFlag |= TiltHall;
            CounterMotorYStepPostionCurrent 	= MotorYResetBackPostion-StartPostion-MaxStep*200;//StartPostion+MaxStep*100;
            //DMXData[pDMX->Tilt] 		= 0;
		}

        if (SuccessFlag == 0x03)
        {
            Index = 9;
        }
	}   //----END while 1----
    
    
    printf("===>HallOutTime->%d__Index->%d \r\n",HallOutTime,Index);
    //------------------------------------------
	if (Index != 9)	
	{
		if (!(SuccessFlag&0x01))
		{
		//Motor1ResetBackPostion
		LEDErrorStatus |= ErrorPanHall;
		//CounterMotorXStepPostionCurrent 	= MotorXResetBackPostion;
		//DMXData[pDMX->Pan] 				= 0;
 		//DisplayLine(1," !!!Warning!!!  ");
		//DisplayLine(2,"ErrPanHallSensor");
		//delayms(2000);
		}
		if (!((SuccessFlag>>1)&0x01))
		{
		//Motor2ResetBackPostion
		LEDErrorStatus |= ErrorTiltHall;
		//CounterMotorYStepPostionCurrent 	= MotorYResetBackPostion;
		//DMXData[pDMX->Tilt] 			= 0;
 		//DisplayLine(1," !!!Warning!!!  ");
		//DisplayLine(2,"ErrTiltHallSenso");
		//delayms(3000);
		}
	}

    //-------------------------------------------------------------------------
    MotorXStep_StartStop = 350;  //最高速度
    Motor1_postion_user  = 0;
    CounterPanEncoder    = 0;
    //-------------------------------------------------------------------------
    
    
    
    

}

//===============================================================================
void TestMotorFucn(void)   //test?
{
    
     static u16 i = 0; 
 
      i++;
      
      delayms(100);
      
   
      if (i == 1)
      {
         MotorXDmxDataControl(255,0);
         MotorYDmxDataControl(255,0);  
      }
      else if (i == 60)
      {
         MotorXDmxDataControl(0,0);
         MotorYDmxDataControl(0,0);  
      }
      else if (i == 120)
      {
         i = 0;
      }
      
    
//          MotorXDmxDataControl(RXDData[1],RXDData[2]);
//          MotorYDmxDataControl(RXDData[3],RXDData[4]);
//          
//          Motor1DmxDataControl(RXDData[5],0);
//          Motor2DmxDataControl(RXDData[6],0);
      
    if ((i%10)==0) //COM串口打印显示
    {
        //ENCODER
        //if (Motor1_postion_user != CounterPanEncoder*2*MaxStep)
        //{
        //    CounterMotorXStepPostionCurrent = CounterPanEncoder*2*MaxStep;//+StartPostion;
        //}
      
       printf("%d_CounterPanEncoder-->%d\r\n",i,CounterPanEncoder);     //
      
      //printf("%d_CounterTiltEncoder-->%d\r\n",i,CounterTiltEncoder);  //
      
      //printf("%d_RXDData[i]-->%d,%d,%d,%d,%d,%d \r\n",i,RXDData[0],RXDData[1],RXDData[2],RXDData[3],RXDData[4],RXDData[5]);  //RXDData
       printf("i->%d user->%d Current->%d pointer->%d SpeedPos->%d  \r\n",i,Motor1_postion_user,Motor1_postion_Current,MotorPositionPointer,MotorXSpeedPos);
    }

}

























/***************************************************************************************************************
*                                             END
***************************************************************************************************************/
